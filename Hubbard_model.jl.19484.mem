        - # using SU(2) ±1,±2 HS transformation
        - 
        - 
        - struct _Hubbard_Para
      112     Lattice::String
        -     t::Float64
        -     U::Float64
        -     site::Vector{Int64}
        -     Θ::Float64
        -     Ns::Int64
        -     Nt::Int64
        -     K::Array{Float64,2}
        -     BatchSize::Int64
        -     WrapTime::Int64
        -     Δt::Float64
        -     α::Float64
        -     γ::Vector{Float64}
        -     η::Vector{Float64}
        -     Pt::Array{Float64,2}
        -     HalfeK::Array{Float64,2}
        -     eK::Array{Float64,2}
        -     HalfeKinv::Array{Float64,2}
        -     eKinv::Array{Float64,2}
        -     nodes::Vector{Int64}
        - end
        - 
        - function Hubbard_Para(t, U, Lattice::String, site, Δt, Θ, BatchSize, Initial::String)
        0     Nt = 2 * cld(Θ, Δt)
        0     WrapTime = div(BatchSize, 2)
        -     
        0     α = sqrt(Δt * U / 2)
       96     γ = [1 + sqrt(6) / 3, 1 + sqrt(6) / 3, 1 - sqrt(6) / 3, 1 - sqrt(6) / 3]
       96     η = [sqrt(2 * (3 - sqrt(6))), -sqrt(2 * (3 - sqrt(6))), sqrt(2 * (3 + sqrt(6))), -sqrt(2 * (3 + sqrt(6)))]
        -     
        0     K = K_Matrix(Lattice, site)
        0     Ns = size(K, 1)
        - 
        0     E, V = eigen(t * K)
        -     
     1392     exp_neg_half = exp.(-Δt .* E ./ 2)
     1392     exp_neg = exp.(-Δt .* E)
     1392     exp_pos_half = exp.(Δt .* E ./ 2)
     1392     exp_pos = exp.(Δt .* E)
        - 
       16     HalfeK = V * diagm(exp_neg_half) * V'
       16     eK = V * diagm(exp_neg) * V'
       16     HalfeKinv = V * diagm(exp_pos_half) * V'
       16     eKinv = V * diagm(exp_pos) * V'
        - 
   105127     Pt = zeros(Float64, Ns, div(Ns, 2))  # 预分配 Pt
        - 
        0     if Initial == "H0"
        0         KK = copy(K)
        -         μ = 1e-5
        0         if occursin("HoneyComb", Lattice)
        0             KK .+= μ * diagm(repeat([-1, 1], div(Ns, 2)))
        0         elseif Lattice == "SQUARE"
        0             for i in 1:Ns
        0                 x, y = i_xy(Lattice, site, i)
        0                 KK[i, i] += μ * (-1)^(x + y)
        0             end
        -         end
        0         E, V = eigen(KK)
        0         Pt .= V[:, 1:div(Ns, 2)]
        0     elseif Initial == "V"
        0         for i in 1:div(Ns, 2)
        0             Pt[i * 2, i] = 1
        0         end
        -     end
        - 
        0     if div(Nt, 2) % BatchSize == 0
        0         nodes = collect(0:BatchSize:Nt)
        -     else
        0         nodes = vcat(0, reverse(collect(div(Nt, 2) - BatchSize:-BatchSize:1)), collect(div(Nt, 2):BatchSize:Nt), Nt)
        -     end
        - 
      256     return _Hubbard_Para(Lattice, t, U, site, Θ, Ns, Nt, K, BatchSize, WrapTime, Δt, α, γ, η, Pt, HalfeK, eK, HalfeKinv, eKinv, nodes)
        - end
        - 
        - function setμ(model::_Hubbard_Para, μ)
        -     N_particle = Int(round(μ^2 / (4 * π) * model.Ns))
        -     E, V = eigen(model.K)
        -     model.Pt .= V[:, 1:N_particle]
        - end
        - 
        - # function setNN_hopping(t)
        -     
        - # end

        - # 120° basis
        - # PBC, OBC is not allowed
        - function nn2idx(Lattice::String,site::Vector{Int64},idx::Int64)
        0     if Lattice=="SQUARE"
        0         if length(site)==2
        0             x,y=i_xy(Lattice,site,idx)
        0             nn=zeros(Int,4)
        0             nn[1]=xy_i(Lattice,site,mod1(x+1,site[1]),mod1(y,site[2]))
        0             nn[2]=xy_i(Lattice,site,mod1(x-1,site[1]),mod1(y,site[2]))
        0             nn[3]=xy_i(Lattice,site,mod1(x,site[1]),mod1(y+1,site[2]))
        0             nn[4]=xy_i(Lattice,site,mod1(x,site[1]),mod1(y-1,site[2]))
        -         else
        0             nn=[location[1]-1,location[1]+1]
        -         end
        - 
        0     elseif  Lattice=="HoneyComb120"
    12960         nn=zeros(Int,3)
        0         x,y=i_xy(Lattice,site,idx)
        - 
        0         if mod(idx,2)==1
        0             nn[1]=idx+1
        0             nn[2]=xy_i(Lattice,site,mod1(x+1,site[1]),y)
        0             nn[3]=xy_i(Lattice,site,x,mod1(y-1,site[2]))
        - 
        -         else
        0             nn[1]=idx-1
        0             nn[2]=xy_i(Lattice,site,x,mod1(y+1,site[2]))-1
        0             nn[3]=xy_i(Lattice,site,mod1(x-1,site[1]), y)-1
        -         end
        - 
        0     elseif  Lattice=="HoneyComb60"
        0         nn=zeros(Int,3)
        0         x,y=i_xy(Lattice,site,idx)
        - 
        0         if mod(idx,2)==1
        0             nn[1]=idx+1
        0             nn[2]=xy_i(Lattice,site,mod1(x+1,site[1]),mod1(y-1,site[2]))
        0             nn[3]=xy_i(Lattice,site,x,mod1(y-1,site[2]))
        - 
        -         else
        0             nn[1]=idx-1
        0             nn[2]=xy_i(Lattice,site,x,mod1(y+1,site[2]))-1
        0             nn[3]=xy_i(Lattice,site,mod1(x-1,site[1]), mod1(y+1,site[2]))-1
        -         end
        -     else    
        0         error("Lattice: $(Lattice) is not allowed !")
        -     end
        0     return nn
        - end
        - 
        - 
        - function xy_i(Lattice::String,site::Vector{Int64},x::Int64,y::Int64)::Int64
        0     if Lattice=="SQUARE"
        0         if length(site)==2
        0             if x>site[1] || y>site[2]
        0                 println()
        0                 error("Error :($x,$y) Out of Lattice Range$(site)!")
        -             end
        0             return x+(y-1)*site[1]
        -         else
        0             error("Error : Dimension wrong")
        -         end
        - 
        - 
        0     elseif  occursin("HoneyComb", Lattice)
        0         if x>site[1] ||y>site[2]
        0             error("Error : Out of Lattice Range!")
        -         end
        0         return 2*(x+(y-1)*site[1])
        -     else
        0         error("Not support $Lattice")
        -     end
        - end
        - 
        - function i_xy(Lattice::String,site::Vector{Int64},i::Int64)
        0     if  Lattice=="SQUARE"
        0         if i>prod(site)
        0             error("Out of Lattice Range")
        -         else
        0             x=mod1(i,site[1])
        0             y=cld(i,site[1])
        0             return x::Int64,y::Int64
        -         end
        0     elseif  occursin("HoneyComb", Lattice)
        0         j=Int(ceil(i/2))
        0         return mod1(j,site[1]),Int(ceil(j/site[1]))
        -     else
        0         error("Not support $Lattice")
        -     end
        - end
        - 
        - 
        - function K_Matrix(Lattice::String,site::Vector{Int64})
        0     if Lattice=="SQUARE"
        0         Ns=prod(site)
        0         K=zeros(Float64,Ns,Ns)
        -         
        0     elseif occursin("HoneyComb", Lattice)
        0         Ns=prod(site)*2
   210087         K=zeros(Float64,Ns,Ns)
        -     end
        - 
        0     for i in 1:Ns
        0         nnidx=nn2idx(Lattice,site,i)
     5184         for idx in nnidx
        0             K[i,idx]=1
    10368         end
        0     end
        0     return K
        - end
        - 
        - 
        - 
        - function area_index(Lattice::String,site::Vector{Int64},area::Tuple{Vector{Int64}, Vector{Int64}})::Vector{Int64}
        0     if Lattice=="SQUARE"
        0         if length(site)==1
        0             index=[x for x in area[1][1]:area[2][1]]
        0             return index
        - 
        0         elseif length(site)==2
        -             counter=1
        0             index=zeros(Int64,prod(area[2]-area[1]+[1,1]))
        0             for lx in area[1][1]:area[2][1]
        0                 for ly in area[1][2]:area[2][2]
        0                     index[counter]=xy_i(Lattice,site,lx,ly)
        0                     counter+=1
        0                 end
        0             end
        0             return index
        -         end
        0     elseif occursin("HoneyComb", Lattice)
        - 
        0         L=site[1]
        0         if area[1][1]==-1
        0             if Lattice=="HoneyComb60"
        0                 println("zigzag")
        0                 index=collect(4:2:xy_i(Lattice,site,L-1,1))
        -                 
        0                 for i in 2:div(2*L,3)
        0                     index=vcat(collect(xy_i(Lattice,site,2,i)-1   :1:  xy_i(Lattice,site,L-i,i) ),index)
        0                 end
        0                 return index        
        -             else
        0                 error("zigzag Only for HoneyComb60°")
        -             end
        -         
        0         elseif area[1][1]==-2
        0             if Lattice=="HoneyComb60"
        0                 index=Vector{Int64}()
        0                 println("beared")
        0                 for i in 2:div(2*L,3)
        0                     index=vcat(xy_i(Lattice,site,2,i)-1,index)
        0                     index=vcat(collect(xy_i(Lattice,site,3,i)-1   :1:  xy_i(Lattice,site,L-i+1,i)-1 ),index)
        0                 end
        0                 index=vcat(xy_i(Lattice,site,2,div(2*L,3)+1)-1,index)
        0                 return index 
        -             else
        0                 error("beared Only for HoneyComb60°")
        -             end
        -         else
        -             counter=1
     1056             index=zeros(Int64,2*prod(area[2]-area[1]+[1,1]))
        0             for lx in area[1][1]:area[2][1]
        0                 for ly in area[1][2]:area[2][2]
        0                     index[counter]=xy_i(Lattice,site,lx,ly)-1
        0                     index[counter+1]=index[counter]+1
        0                     counter+=2
        0                 end
        0             end
        0             return index
        -         end
        -     end
        - 
        - end
